World Radio History
BYTE
AUGUST 1990

STATE OF THE ART
FULL CIRCLE


Need to Know
The split between user and power-user languages is not along application lines. In almost every category, from communications programs to word processors, some software companies have opted for easy-to-use languages while others have chosen languages that wring the most power they can out of the machine. This is especially obvious in database languages. Because databases put such heavy demands on the system, they tend to use power-user languages. In an attempt to make their DBMSes as easy to use as possible, some companies are even willing to sacrifice some power. One of the more interesting trends in applications is to provide more than one language. In addition to a power-user language, some packages now offer a simpler scripting or macro language for casual use. AutoCAD, for instance, not only has AutoLisp and facilities for writing C routines, but it also has a menu-ori-ented facility that is much easier to use. You can make too much of the entire question of user versus power-user languages. Most people have a strong abilityto learn the information they need to do their jobs, and if they have to, they canmaster nearly anything.

Roots
As computer languages, applications languages are a real grab bag. Some of them are based on well-known programming languages, occasionally so closely that programs are virtually indistinguishable. Others go off in new directions and do things unlike any conventional language. In some cases, the basis for the language is well thought out. In others, it seems to be whatever appealed to the programmer. More to the point, some applications languages are easy to use, with appropriate interfaces and powerful control structures, while others barely qualify as languages. Of course, the easiest languages to use are the natural-language interfaces found on some database systems. There isn't alot of consistency in any of this. You find some of the worst excuses for languages in some of the most expensive professional packages, and some of the best in inexpensive programs. There is atendency for more recent packages to have better applications languages, but that's hardly universal rule. One of the reasons for so much variation is that, as a rule, the language isn't a major selling point for the application. There isn't the pressure to improve it that there is for other features.

Again, this isn't universal. Some companies, such as Clarion Software, have built their advertising around their applications languages. In general, DBMS users are more concerned than others about the languages. Popular models for applications languages include C and Pascal. C-like languages tend to be power-user languages. They generally have the advantages of C: They're terse, capable, and small. Pascal is a popular model in a variety of applications. Probably the best known is HyperTalk, the language behind HyperCard. Using Pascal as a model tends to produce a language that is readable and has well-defined control structures, at the expense of being verbose and taking up more memory. There is also more of a tendency to include type declarations in Pascal-like languages. BASIC is also a popular model. Its popularity has slipped, however, as its use in serious programming has waned.

The Little Guys
Besides the major languages, some of the lesser-known ones have also served as models for applications languages. AutoLisp is the best example. Lisp was chosen as the basis for AutoCAD's programming language because the designers thought it was a good fit with what they needed to do, not because the application was written in Lisp — it wasn't. Lisp is designed to interpretively process variable-length lists of heterogeneous items. The coordinates of a point on a CAD drawing and the properties associated with that point can be treated as a list. Because Lisp is interpreted, it is interactive. Given enough computing power, lists are evaluated almost instantly. That makes it easy to make a change to a drawing, examine the results, and change it again if it wasn't what you wanted.
Some applications have used Forth or a Forth-like language. For instance, PostScript is similar to Forth. Forth's strengths include small size, extensibility, and the ability to work very closely with hardware—all of which are important for a language that controls laser printers. Basing an applications language on an existing computer language is aboon to the software developers, because they can draw on experience when they write other implementations of the language. For users, the picture is mixed. If you're familiar with the model language, it's a good approach. You can learn the language more quickly if it works  like something you already know. However, the point of applications languages is that, these days, most users don't know any
conventional computer language. 

Picture-Perfect Programming
Although most user languages are based on conventional ones, there is nothing that says they have to be. Many companies have used languages that are not like any of the major programming languages. One increasingly popular approach is iconic. Examples include the Double Helix DBMS from Odesta for the Macintosh, and Bars and Pipes, a MIDI program from Blue Ribbon Bakery for the Amiga. In an iconic language, commands and conditionals are represented by icons. You build programs by stringing together icons and adding more information as needed.
Iconic languages are especially popular for multimedia authoring. Making multimedia work requires blending images, sounds, and other resources in tight synchronization. If things get out of sync, the words don't match the pictures, and the video effects may not match either. That can be annoying or amusing, but it definitely isn't what you want. To ensure that everything stays synchronized, directors who do multimedia projects without computers use various forms of graphics notation. An iconic multimedia authoring language refines and continues the trend. At first glance, the idea of a picto
